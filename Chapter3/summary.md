# 程序的机器级表示 #

## 历史观点 ##

## 程序编码 ##

1. C预处理器处理include和define等宏命令；编译器产生源文件的汇编代码（*.s）；汇编器将汇编代码转为二进制目标代码文件（*.o），目标代码包含所有指令的二进制表示，但没有填入全局值的地址；最后，链接器将目标代码与实现库（例如printf）的代码合并，产生可执行文件。
2. 对于机器级编程重要的两种抽象：

    - ISA，指令集体系结构或指令集架构，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。
    - 虚拟地址，内存模型看上去是一个非常大的字节数组。
3. 机器代码可见的处理器状态信息：

    - PC，程序计数器（%rip），给出将要执行的下一条指令在内存中的地址。
    - 整数寄存器，包含16个命名的位置，分别存储64位的值。用来记录程序状态或保存临时数据。
    - 条件码寄存器，保存着最近执行的算术或逻辑指令的状态信息。用来实现控制或数据流中的条件变化。
    - 一组向量寄存器，存放一个或多个整数或浮点数值。

## 数据格式 ##

## 访问信息 ##

1. 整数寄存器。所有16个寄存器的低位部分都可以作为字节、字（16位）、双字（32位）和四字（64位）数字来访问：

| 64 | 32  | 16  | 8    |   描述    |
|----|-----|-----|------|-----------|
|rax |eax  |ax   | al   |返回值      |
|rbx |ebx  |bx   | bl   |被调用者保存 |
|rcx |ecx  |cx   | cl   |第4个参数   |
|rdx |edx  |dx   | dl   |第3个参数   |
|rsi |esi  |si   | sil  |第2个参数   |
|rdi |edi  |di   | dil  |第1个参数   |
|rbp |ebp  |bp   | bpl  |被调用者保存 |
|rsp |esp  |sp   | spl  |栈指针      |
|r8  |r8d  |r8w  | r8b  |第5个参数   |
|r9  |r9d  |r9w  | r9b  |第6个参数   |
|r10 |r10d |r10w | r10b |调用者保存  |
|r11 |r11d |r11w | r11b |调用者保存  |
|r12 |r12d |r12w | r12b |被调用者保存 |
|r13 |r13d |r13w | r13b |被调用者保存 |
|r14 |r14d |r14w | r14b |被调用者保存 |
|r15 |r15d |r15w | r15b |被调用者保存 |

2. 生成1字节和2字节数字的指令会保持剩下的字节不变；生成4字节数字的指令会把高位4字节置为0。
3. 大多数指令有一个或多个操作数，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置：

    - 立即数，用来表示常数值。书写方式是'$'后面跟一个标准C整数。
    - 寄存器，表示某个寄存器的内容。
    - 内存引用，根据计算出来的地址（有效地址）访问某个内存位置。

4. 寻址模式，四个组成部分（立即数偏移Imm，基址寄存器$\text{r}_b$必须64位，变址寄存器$\text{r}_i$必须64位，比例因子s必须是1、2、4或者8）：

|   类型    |   格式                            |   操作数值                                      |   名称              |
|----------|-----------------------------------|-----------------------------------------------|--------------------|
|   立即数  |   $Imm                            |   Imm                                         |   立即数寻址         |
|   寄存器  |$\text{r}_a$                       |R[$\text{r}_a$]                                |   寄存器寻址         |
|   存储器  |   Imm                             |M[Imm]                                         |   绝对寻址           |
|   存储器  |($\text{r}_a$)                     |M[R[$\text{r}_a$]]                             |   间接寻址           |
|   存储器  |Imm($\text{r}_b$)                  |M[Imm+R[$\text{r}_b$]]                         |   (基址+偏移量)寻址   |
|   存储器  |($\text{r}_b$,$\text{r}_i$)        |M[R[$\text{r}_b$]+R[$\text{r}_i$]]             |   变址寻址           |
|   存储器  |Imm($\text{r}_b$,$\text{r}_i$)     |M[Imm+R[$\text{r}_b$]+R[$\text{r}_i$]]         |   变址寻址           |
|   存储器  |(,$\text{r}_i$,s)                  |M[R[$\text{r}_i$]$\cdot$s]                     |   比例变址寻址        |
|   存储器  |Imm(,$\text{r}_i$,s)               |M[Imm+R[$\text{r}_i$]$\cdot$s]                 |   比例变址寻址        |
|   存储器  |($\text{r}_b$,$\text{r}_i$,s)      |M[R[$\text{r}_b$]+R[$\text{r}_i$]$\cdot$s]     |   比例变址寻址        |
|   存储器  |Imm($\text{r}_b$,$\text{r}_i$,s)   |M[Imm+R[$\text{r}_b$]+R[$\text{r}_i$]$\cdot$s] |   比例变址寻址        |

5. 数据传送指令：

    - （MOV S,D）（'b'\'w'\'l'\'q'），第一个是源操作数，第二个是目的操作数。寄存器部分的大小必须与指令最后一个字符指定的大小匹配。特殊的用movabsq指令以任意64位立即数值作为源操作数，并且只能以寄存器作为目的。
    - （MOVZ S,R）（'bw'\'bl'\'bq'\'wl'\'wq'），以零扩展进行传送。将较小的源值复制到较大的目的时使用，以寄存器或内存地址作为源，以寄存器作为目的。特殊的没有movzlq，可以用movl指令来实现。利用的属性是，生成4字节值并以寄存器作为目的的指令会把高4字节置为0。
    - （MOVS S,R）（'bw'\'bl'\'bq'\'wl'\'wq'\'lq'），以符号扩展进行传送。将较小的源值复制到较大的目的时使用，以寄存器或内存地址作为源，以寄存器作为目的。特殊用cltq把%eax符号扩展到%rax。
    - （push S\pop D）（'b'\'w'\'l'\'q'），栈指针%rsp保存着栈顶元素的地址。将一个四字值压入栈中，首先要将栈指针减8，然后将新值写到新的栈顶位置。弹出一个四字的操作同理。程序也可以用标准的内存寻址方法访问栈内的任意位置。

## 算术和逻辑操作 ##

1. 以下未特别指明都包含四种不同大小数据的指令：
    - （leap S,D），加载有效地址，目的操作数必须是一个寄存器。不包含四种不同大小数据的指令。
    - （INC D），加1，一元操作，操作数可以是一个寄存器或内存位置。后面同理。
    - （DEC D），减1
    - （NEG D），取负
    - （NOT D），取补
    - （ADD S,D)，加，二元操作，源操作数是第一个，目的操作数是第二个，第一个操作数可以是立即数、寄存器或内存位置。第二个操作数可以是寄存器或内存位置。注意不能同时将内存位置作为源和目的操作数。后面同理。
    - （SUB S,D)，减
    - （IMUL S,D)，乘
    - （XOR S,D)，异或
    - （OR S,D)，或
    - （AND S,D)，与
    - （SAL\SHL k,D)，左移，移位操作，k是移位量。移位量可以是立即数，或者放在单字节寄存器%cl中。对w位长的数据进行操作，实际的移位量是由%cl寄存器的低m位决定的，$2^m=w$，多余的位会被忽略。目的操作数可以是寄存器或内存位置。
    - （SAR k,D)，算术右移
    - （SHR k,D)，逻辑右移
2. Intel把16字节的数称为八字，以下是支持产生两个64位数字的全128位乘积以及整数除法的指令：
    - （imulq S)，有符号全乘法，要求一个参数必须在寄存器%rax中，另一个作为指令的源操作数给出。乘积存放在寄存器%rdx（高64位）和%rax（低64位）中。
    - （mulq S)，无符号全乘法
    - （clto），转换为八字
    - （idivq S），有符号除法，将寄存器%rdx（高64位）和%rax（低64位）中的128位数作为被除数，除数作为指令的操作数给出。指令将商存储在寄存器%rax中，将余数存储在寄存器%rdx中。
    - （divq S），无符号除法，通常%rdx会事先设置为0。
    - （cqto\cqo），它隐含的读出%rax的符号位，并将它复制到%rdx的所有位。

## 控制 ##

1. CPU维护一组单个位的条件码寄存器，它们描述了最近的算术或逻辑操作的属性：

    - CF，进位标志。最高位产生了进位，检查无符号操作的溢出。
    - ZF，零标志，得到结果为0。
    - SF，符号标志，得到结果为负数。
    - OF，溢出标志，导致一个补码溢出（正溢出或负溢出）。

2. 除leaq指令外**算术和逻辑操作1**中其他指令都会改变条件码：
    - CMP（'b'/'w'/'l'/'q'） $S_1,S_2$，类似SUB，只设置条件码而不更新目的寄存器。
    - TEST（'b'/'w'/'l'/'q'） $S_1,S_2$，类似AND。

3. 根据条件码的某种组合，将一个字节设置为0或者1：
    |指令       |同义名         |效果                 |设置条件           |
    |-----------|--------------|--------------------|-----------------|
    |sete   D   |setz          |D <- ZF             |相等/零           |
    |setne  D   |setnz         |D <- ~ZF            |不相等/非零        |
    |sets   D   |              |D <- SF             |负数              |
    |setns  D   |              |D <- ~SF            |非负数            |
    |setg   D   |setnle        |D <- ~(SF^OF) & ~ZF |大于（有符号>)     |
    |setge  D   |setnl         |D <- ~(SF^OF)       |大于等于（有符号>=) |
    |setl   D   |setnge        |D <- SF^OF          |小于（有符号<)     |
    |setle  D   |setng         |D <- (SF^OF) \| ZF   |小于等于（有符号<=) |
    |seta   D   |setnbe        |D <- ~CF \| ~ZF      |超过（无符号>)      |
    |setae  D   |setnb         |D <- ~CF            |超过或相等（无符号>=)|
    |setb   D   |setnae        |D <- CF             |低于（无符号<)      |
    |setbe  D   |setna         |D <- CF \| ZF        |低于或相等（无符号<=)|
